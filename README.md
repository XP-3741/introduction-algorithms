# introduction-algorithms

排序：
	Ⅰ 插入排序
	Ⅱ 归并排序
		2165. 重排数字的最小值
		1451. 重新排列句子中的单词
	Ⅲ 堆排序
		1481. 不同整数的最少数目	---[当排序数组过大时超出时间限制，但将两个vector数组都使用堆排序在处理，便不会超时]
		1040. 移动石子直到连续 II	---[未懂]
		881. 救生艇
	Ⅳ 快速排序
		2126. 摧毁小行星---[因为遇到特殊循序的超大数组，排序超时，改为堆排序]
	Ⅴ 模糊排序
		452. 用最少数量的箭引爆气球---[采用快速排序，但在一个测试例子时，特别多的已经排序好的元素导致时间超时]
	Ⅵ 计数排序
		1288. 删除被覆盖区间---[主要遇到B数组越界问题]
	Ⅶ 基数排序
	Ⅷ 桶排序

二叉搜索树：
	98. 验证二叉搜索树---[递归+栈，执行用时，在所有 C++ 提交中击败了97.27%的用户]
	1373. 二叉搜索子树的最大键值和---[查找二叉搜索树采用98的方式，主要困扰，首先找到的最大和二叉树中的结点可能包含负值，
							所以真正最大和二叉树可能为其子树，解决方案：采用动态数组存储每个子树和然后找出最大值
							执行用时，在所有 C++ 提交中击败了98.86%的用户
							内存消耗，在所有 C++ 提交中击败了92.13%的用户]
	面试题 04.09. 二叉搜索树序列---[未懂，采用了评论方法，回溯]

动态规划：
	376. 摆动序列---[未懂
				注意省题,否则白忙活]
	198. 打家劫舍---[自底向上,按照动态规划四步骤,原问题依赖的最右子问题是什么,并且要记录每个子问题的最优解
				执行用时，在所有 C++ 提交中击败了100%的用户
				内存消耗，在所有 C++ 提交中击败了72.68%的用户
				但是缺少空间优化,此题并不需要保存之前所有的子数组最优解
				只需要保存前和前前个即可,甚至不用判断遍历到的i前一家是否被偷窃
				参考评论,优化后,内存消耗击败97.49%的用户]
	1262. 可被三整除的最大和---[参考了评论
						自己的问题：未能正确找到子问题和子数组
						注意题目特点]
	107. 矩阵中的距离---[参考了官方答案
					在矩阵中寻找距离不一定要如同DFS或BFS一样一直延申到头
					每个元素取左上向右下遍历，右下向左上遍历
					取与本身比较较小值，也可以做出此效果
					总结：要思考最有子问题存在哪几种可能，按照不同的可能列写递推式]

数学：
	779. 第K个语法符号---[找规律+递归，执行用时，在所有 C++ 提交中击败了100%的用户]
	2033. 获取单值网格的最小操作数---[将二维数组转成一维并排序，找中间元素作为相等值]
	970. 强整数---[经验：递归太过浪费的占用内存和运行时间，过多重复，以及1的任何次幂都是1，忽略是程序进入死循环
			   内存消耗，在所有 C++ 提交中击败了83.74%的用户
				运用评论区方法，执行用时，在所有 C++ 提交中击败了100%的用户
						       内存消耗，在所有 C++ 提交中击败了60.89%的用户，不过没看懂]

栈：
	224. 基本计算器---[看的官方解答,用1和-1代替＋和-,并利用压栈出栈代表运算的括号里面符号是否受括号前运算符影响]
